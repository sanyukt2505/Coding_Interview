package problem.dynamic;

import java.util.PriorityQueue;

/**Huffman encoding is a lossless freq compression algorithm where each character in the freq is assigned a variable
 * length prefix code. The least frequent character gets the largest code and the most frequent one gets the smallest
 * code.
 * https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/
 * There are mainly two major parts in Huffman Coding
 *      1) Build a Huffman Tree from input characters.
 *      2) Traverse the Huffman Tree and assign codes to characters.
 * 1. Create a leaf node for each unique character and build a min heap of all leaf nodes (Min Heap is used as a priority queue.
 * 2. Extract two nodes with the minimum frequency from the min heap.
 * 3. Create a new internal node with a frequency equal to the sum of the two nodes frequencies.
 *      Make the first extracted node as its left child and the other extracted node as its right child. Add this node to the min heap.
 * 4. Repeat steps#2 and #3 until the heap contains only one node. The remaining node is the root node and the tree is complete.
 *
 * Image Compression - Consider image to be built by 4X$ pixel so create ur node (pixel intensity, frquency)
 */
public class Huffman {

    static class Node implements Comparable<Node>{
        int freq;
        char c;

        Node left;
        Node right;

        @Override
        public int compareTo(Node n) {
            return this.freq - n.freq;
        }
    }

    public static void printCode(Node root, String s)
    {

        // base case; if the left and right are null then its a leaf node and we print
        // the code s generated by traversing the tree.
        if (root.left == null && root.right == null && Character.isLetter(root.c)) {
            // c is the character in the node
            System.out.println(root.c + ":" + s);
            return;
        }

        // if we go to left then add "0" to the code.
        // if we go to the right add"1" to the code.
        // recursive calls for left and
        // right sub-tree of the generated tree.
        printCode(root.left, s + "0");
        printCode(root.right, s + "1");
    }

    public static void decode(Node root, String s) {
        String ans = "";
        Node curr = root;

        for (int i=0; i < s.length(); i++) {
            if(s.charAt(i) == '0')
                curr = curr.left;
            else
                curr = curr.right;

            //reached leaf node
            if (curr.left == null && curr.right == null) {
                ans = ans + curr.c;
                curr = root;
            }
        }
        System.out.println("Decoded string: "+ ans);
    }

    public static void main(String[] args)
    {
        // number of characters.
        int n = 6;
        char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' };
        int[] charFreq = { 15, 9, 12, 23, 16, 45 };


        /**
         * If you are not allowed to use PriorityQueue. U can sort it and add it to one queue
         * use a second queue to store the internal generated nodes
         * Dequeue two nodes with the minimum frequency by examining the front of both queues. Repeat following steps two times
         * …..a) If second queue is empty, dequeue from first queue.
         * …..b) If first queue is empty, dequeue from second queue.
         * …..c) Else, compare the front of two queues and dequeue the minimum.
         */
        // creating a priority queue q. makes a min-priority queue(min-heap).
        PriorityQueue<Node> q
                = new PriorityQueue<Node>(n);

        for (int i = 0; i < n; i++) {

            // creating a Huffman node object and add it to the priority queue.
            Node hn = new Node();
            hn.c = charArray[i];
            hn.freq = charFreq[i];

            hn.left = null;
            hn.right = null;

            // add functions adds the huffman node to the queue.
            q.add(hn);
        }

        // create a root node
        Node root = null;

        // Here we will extract the two minimum value from the heap each time until
        // its size reduces to 1, extract until all the nodes are extracted.
        while (q.size() > 1) {

            // first and second min extract.
            Node x = q.peek();
            q.poll();
            Node y = q.peek();
            q.poll();

            // new node f which is equal
            Node f = new Node();

            // to the sum of the frequency of the two nodes assigning values to the f node.
            f.freq = x.freq + y.freq;
            f.c = '-';

            // first extracted node as left child.
            f.left = x;
            // second extracted node as the right child.
            f.right = y;
            // marking the f node as the root node.
            root = f;
            // add this node to the priority-queue.
            q.add(f);
        }

        // print the codes by traversing the tree
        printCode(root, "");
    }
}
